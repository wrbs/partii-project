% !TeX root = ../dissertation.tex
\chapter{Implementation}

\section{Overview}

\section{Overview of repository}

\dirtree{%
    .1 /.
    .2 benchmarks.
    .3 sandmark\DTcomment{fork of the Sandmark benchmark suite to support bytecode}.
    .3 analysis\DTcomment{Jupyter notebooks analysing benchmark results}.
    .2 docs\DTcomment{{\LaTeX} source of proposal, report and this document}.
    .2 scripts\DTcomment{scripts to run tests and graph basic blocks}.
    .3 run\_tests.sh\DTcomment{runs the entire suite of benchmark tests}.
    .2 src.
    .3 rust.
    .4 ocaml-jit-shared\DTcomment{shared library between the other two crates}.
    .4 ocaml-jit-staticlib\DTcomment{crate linked in to OCaml runtime}.
    .4 ocaml-jit-tools\DTcomment{standalone tools used for testing}.
    .3 ocaml\DTcomment{contains a fork of the entire OCaml compiler}.
    .4 runtime\DTcomment{where most modifications to the OCaml compiler happened}.
    .5 jit\_support.c\DTcomment{contains C primitives used by the compiled code}.
    .3 vendor\DTcomment{contains forked Rust dependencies}.
    .2 test-programs\DTcomment{OCaml source for the test programs used by the scripts}.
    .2 no-aslr\DTcomment{A simple wrapper to run a program without ASLR}.
}

\subsection{ocaml-jit-shared crate}

\dirtree{%
    .1 src/rust/ocaml-jit-shared.
    .2 Cargo.toml\DTcomment{specifies dependencies}.
    .2 src.
    .3 basic\_blocks\DTcomment{contains types and algorithm for converting an instruction stream to
        basic blocks}.
    .3 cranelift\_compiler.
    .4 mod.rs\DTcomment{Contains the bulk of the implementation of the optimised compiler}.
    .4 test\_cases\DTcomment{Contains many expect-test cases}.
    .3 instructions.
    .4 parse.rs\DTcomment{contains the parser for OCaml bytecode}.
    .4 types.rs\DTcomment{defines the core instruction types used everywhere}.
}

\subsection{ocaml-jit-staticlib crate}

\dirtree{%
    .1 src/rust/ocaml-jit-staticlib.
    .2 Cargo.toml\DTcomment{specifies dependencies}.
    .2 src.
    .3 caml\DTcomment{contains Rust wrappers for OCaml headers}.
    .3 compiler.
    .4 c\_primitives.rs\DTcomment{imports C primitives from the OCaml runtime}.
    .4 emit\_code.rs\DTcomment{contains the bulk of the implementation of the initial compiler}.
    .4 rust\_primitives.rs\DTcomment{contains primitives written in Rust called by JITed code}.
    .4 saved\_data.rs\DTcomment{defines the persistent data structures the compiler adds}.
    .3 c\_entrypoints.rs\DTcomment{glue for C to Rust FFI}.
    .3 configuration.rs\DTcomment{defines the env-var options the JIT has}.
    .3 lib.rs\DTcomment{contains the entrypoints into the Rust code}.
}

\section{The first compiler}

The first compiler uses a fairly direct translation from OCaml bytecode to assembly.

The x86\_64 registers \texttt{r12-r15} (callee-saved in the System V calling convention) are used
to store the OCaml registers - however the system PC is used instead of the bytecode pointer.

I set up aliases for these mappings - in \texttt{dynasm\_rs} assembly things like \texttt{r\_accu}
and
\texttt{r\_sp} map to the actual registers used.

The compiler is triggered on the first time a `section' is loaded - for normal programs this is at
startup and for programs using the OCaml toplevel REPL this is after every statement is typed.

The compiler first emits a standard function header entrypoint which saves callee-saved registers
used by the compiler and aligns the C stack. A longjmp handler is set up for exceptions triggered
by C primitives, then for each bytecode instruction assembly with the same semantics is emitted.

During this process \texttt{dynasm-rs} dynamic labels are used to set up relocations: these
labels are defined before every bytecode instruction and can be referenced by any other instruction

After all instructions are done, some shared code used by the instructions is emitted.
\texttt{dynasm-rs} then uses
\texttt{mmap} to mark the region of code as executable and returns a pointer to the first
instruction and

The main meat of this compiler is the large Rust pattern match. As a somewhat simple example
consider the implementation of the 'ADD' instruction:

In the original interpreter it is implemented as so\footnote{the decrement is to support the OCaml
    integer representation}

\inputminted{c}{snippets/add.c}

In my compiler I emit this as the template:

\inputminted{rust}{snippets/add.rs}

which has exactly the same semantics.

I repeated this process for every bytecode instruction. More involved instructions call into
OCaml runtime or custom-written C functions - the state of the registers is pushed to the stack
and interpreted as a struct by the calling functions.

\subsection{Testing}

\subsubsection{Trace comparison}

Although at a high level this is a simple and fairly direct translation it proved to error-prone.

In order to ensure I had covered as many corner cases as possible I wrote support for emitting
traces of every instruction executed as JSON and added this to both the existing interpreter
and the new JIT. At every trace the entire machine state is logged.

A wrapper program (in the \texttt{ocaml-jit-tools} crate) runs a program with ASLR disabled and
tracing enabled twice
simultaneously - one run uses the JIT and the other the existing interpreter.

Then for every trace entry printed it prints the two lines and if there is a difference highlights
it in red and exits.

I implemented support for doing this very early on in the implementation of the compiler. This
allowed a quick iteration of getting increasingly complicated programs running incrementally,
adding support for new instructions and fixing bugs found by the old ones.

I was initially concerned that non-determinism would be an issue in this approach - especially
due to malloc and how the OS splits up the virtual memory for each process. However in practice
once no-aslr was disabled if the first line of traces matched they kept matching throughout the
execution of the programs.

This can fail for longer running programs which end up triggering a major GC, however none of the
test programs used were.

Once this was done, I used the compiler's test suite to discover some latent bugs and added new
test cases to expose them and fix them using the tracing method.

\subsubsection{Testing}

Once I was happy that I had implemented everything, I used the OCaml compiler's internal test
suite.

This found a few bugs which I fixed by the creation of new trace comparison test programs before
eventually passing
everything \footnote{except for the debugger and backtraces which are explicitly not supported}.

Then I tested self-hosting the compiler using the JIT which was a success. At this point I
considered the phase 1 compiler finished and moved on to the benchmark suite. This is described in
section REF.

\section{Modifications to support dynamic recompilation}

\section{Optimised compiler}

\section{Disassembly tools}