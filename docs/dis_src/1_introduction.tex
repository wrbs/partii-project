% !TeX root = ../dissertation.tex
\chapter{Introduction}

\section{Overview}

The OCaml compiler has two main backends: an optimised target-specific native code compiler and a
compiler to bytecode to be run on the interpreter.

My project aimed to increase the performance of the bytecode interpreter by using the technique
just-in-time (JIT) compilation to x86\_64 machine code. I used the Rust programming language to
implement the compiler.

I implemented two different compilers of differing compilation speed - all bytecode is processed by
the fast but less optimised compiler and functions determined to be 'hot' are processed by the
slower but more sophisticated compiler.

\section{Related work}

I discovered fairly soon into the project that this had been attempted at least twice: with
\textsc{OCamlJit} in 2004 \cite{ocjit1} and \textsc{OCamlJit2} in 2010 \cite{ocjit2}. On advice
of my supervisor I decided not to closely read these papers until after implementation - my
less-optimised compiler independently ended up working in a similar way to \textsc{OCamlJit2} and
my second was more sophisticated than either project.

This project fits into work on JITs as a method-based (as opposed to trace-based) compiler
\cite{pyket}. The first compiler uses \texttt{dynasm-rs} \cite{dynasmrs} which works as a Rust
macro
turning assembly instructions into pre-assembled code and calls into a simple runtime for
relocation. Its design is based on that of \texttt{DynASM} used in the \texttt{LuaJIT} project
\cite{dynasm}.

The second compiler uses the \texttt{cranelift} \cite{cranelift} which is a low-level retargetable
code generator with an emphasis on use in JITs.

\section{Starting point}

The starting point of this project was a fork of the OCaml compiler version 4.11.1 with support for
linking in a Rust static library into the runtime interpreter. I had started work on a simple
disassembler of OCaml bytecode
